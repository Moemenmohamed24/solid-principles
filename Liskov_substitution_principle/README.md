ايه هو ؟ بنستخدمه ليه ؟ بيحل مشكله ايه ؟ يحصل ايه لو مستخدمناهوش ؟ 


 ✅ ايه هو ؟
 لو عندك أي كود بيشتغل مع الأب (مثلاً Shape)، تبقى تقدر تحط أي ابن (مثلاً Circle أو Rectangle) مكانه والكود يفضل شغال زى الاول من غير ما يحصل أي خطأ أو يتصرف بطريقة غريبة , مش يدي نفس النتيجه بس يكون نفس المنطق نفسه في الاساس
يعني إيه استبدال بردو ؟
الاستبدال معناه:
أنا عندي كود مكتوب على أساس الكلاس الأب (T)، والمفروض أقدر أستخدم الكلاس الابن (S) مكانه من غير ما أغير الكود ده، ومن غير ما البرنامج يبوظ أو يدي نتائج غريبة.
معلومه : LSP بيحصل في الruntime :  احنا  اصلا بنستخدم LSP علشان ميحصلش حاجه غلط وقت الruntime او يحصل نتيجه غير متوقعه

توضيح اكتر بمثال بسيط :

Bird كلاس الطيور الاساسي 
class Bird
{
    public:
    virtual void fly()
    {
        cout << "Bird is flying" << endl;
    }
    virtual ~Bird() = default;
};


انا هنا لو بدلت كلاس الاطيور مع النعامه كده غلط لانه هيدي حاجه النعامه مش بتعملها اصلا وهنا الاستبدال غلط علشان كده بنقول انو بيحصل في الruntime او بنقول احنا بنستخدمه علشان نتفادي النتيجه المتوقعه في ان لازم الكلاس الابن يكون بفنس منطق او بنفس تطبيق الكلاس الاب ***** مش لازم نفس النتيجه بالظبط بس لازم نفس الحاجه او نفس الفعل 

class Ostrich : public Bird
{
public:
    void fly() override
{
    throw runtime_error("Ostrich cannot fly!"); // ✖ خطأ
}
};




  ✅بنستخدمه ليه ؟ بيحل مشكله ايه ؟
المشكلة:
•	الكود اللي بيعتمد على Bird يفترض كل الطيور تطير.
•	لما نستخدم Ostrich، استدعاء fly() هيكسر الكود → انتهاك LSP.
يعني LSP بيحل مشكلة:
•	فرض سلوك موحد على Subclasses مش كلها قادرة تنفذه.
•	الاستثناءات غير المتوقعة .



  ✅يحصل ايه لو مستخدمناهوش ؟
  
طبعا علشان كل اللي احنا قلناه فوق ده بيحل مشكله عدم توقع الناتج نفسه وان الاب مينفعش او سلوكه غير الابن  


